


<!DOCTYPE html>
<html lang="">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <!-- responsive-->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Archives [ Hexo ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/elenore/css/elenore.css">
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/css/floekr.css">
    
  
  <link rel="stylesheet" href="/css/highlight/styles/monokai-sublime.css">
  <script src="/js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/cpp.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Navigation Bar -->
<nav id="navbar" class="navbar is-white is-fixed-top">
  <div id="specialShadow" class="el-special-shadow"></div>
  <div class="container">

    <!-- left side, always visible -->
    <div class="navbar-brand">
      <a class="navbar-item" href="/">
        <!-- <strong>Bingo</strong> -->
        <i class="fa fa-lg fa-home"></i>
      </a>

      <!-- toggles the menu on touch devices -->
      <div id="navbarBurger" class="navbar-burger burger" data-target="navMenu">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </div>

    <!-- menu -->
    <div id="navMenu" class="navbar-menu">
        <div class="navbar-end">
          
            
            <a href="/" class="navbar-item">HOME</a>
            

            

            
          
            

            

            
            <a href="/projects" class="navbar-item" >PROJECTS</a>
            
          
            

            
            <a href="/about" class="navbar-item">ABOUT</a>
            

            
          
        </div>
    </div>
  </div>
</nav>

<!-- index hero -->
<div class="hero is-large has-background-fixed" id="indexHero">
  <div class="hero-body">
    <div class="container has-text-centered">
      <p id="titleContent">
        Bingo, <span>Computer Graphics</span> & <span>Game Developer</span>
      </p>
    </div>
  </div>
</div>

<!-- articles and about me -->

<section class="section">
  <div class="container">
    <!-- content and about me -->
    <div class="columns">
      <!-- blog -->
      <div class="column is-two-thirds">
        <div class="columns is-multiline">
          <div class="column is-12">
            <!-- articles -->
            
                
                  <div class="card is-white is-hover" id="articleCard">
                    <div class="card-header">
                      <a href="/2018/03/07/2016-08-31-一阶线性微分方程笔记/" class="card-header-title">
                        一阶线性微分方程笔记
                      </a>
                    </div>
                    <div class="card-content">
                      <p id="articleContent">
                        <blockquote>
<p>考研微分方程计算中，并未包含伯努利方程的要求，但一样可以通过变量代换实现求解。下题为一个经典的变量代换求解，但自己发现却可以使用更巧妙的办法解答，张宇解析中并没有提及，因此记录在此。</p>
</blockquote>
<p>求 $xdy=(1+ylnx)ydx (x&gt;0)$</p>
<hr>
<blockquote>
<p>变量代换:</p>
</blockquote>
<p>$\Rightarrow$ $xy’=y+y^2lnx$</p>
<p>$\Rightarrow$ $\frac{x}{y^2}y’=\frac{1}{y}+lnx$</p>
<blockquote>
<p>令t = $\frac{1}{y}$，那么$\frac{dt}{dx}=-\frac{1}{y^2}\frac{dy}{dx}$</p>
</blockquote>
<p>$\Rightarrow$ $-x\frac{dt}{dx}=t+lnx$</p>
<blockquote>
<p>凑出一阶线性微分方程形式</p>
</blockquote>
<p>$\Rightarrow$ $\frac{dt}{dx}+\frac{1}{x}t=-\frac{lnx}{x}$</p>
<p>$\Rightarrow$ $t=e^{-\int{\frac{1}{x}dx}}(\int{e^{\int{\frac{1}{x}dx}}(-\frac{lnx}{x})dx}+C)$</p>
<p>$\Rightarrow$ $t=\frac{1}{x}(\int{x(-\frac{lnx}{x})dx}+C)=-\frac{1}{x}(xlnx-x+C)=\frac{1}{y}$</p>
<p>$\Rightarrow$ $x=xy-xylnx+Cy$</p>
<hr>
<blockquote>
<p>凑导数形式:</p>
</blockquote>
<p>$\Rightarrow$ $xy’=y+lnxy^2$</p>
<p>$\Rightarrow$ $\frac{y-xy’}{y^2}=-lnx$</p>
<p>$\Rightarrow$ $(\frac{x}{y})’=-lnx$</p>
<p>$\Rightarrow$ $-\frac{x}{y}=xlnx-x+C$</p>
<p>$\Rightarrow$ $x=xy-xylnx+Cy$</p>

                      </p>
                    </div>
                  </div>
                  <br>
                  <br>
                  
                  <div class="card is-white is-hover" id="articleCard">
                    <div class="card-header">
                      <a href="/2018/03/07/2017-08-23-递归删除单链表中特定值/" class="card-header-title">
                        递归删除单链表中特定值
                      </a>
                    </div>
                    <div class="card-content">
                      <p id="articleContent">
                        <blockquote>
<p>理解来自CSDN中的<a href="http://blog.csdn.net/raby_gyl/article/details/13383573" target="_blank" rel="noopener">递归删除算法</a>，个人补充细节描述</p>
</blockquote>
<p>题为「设计递归算法，删除无头结点的单链表L中值为x的结点」</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteX</span><span class="params">(LinkList &amp;L, ElemType x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    LNode *p;  </span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span>;  </span><br><span class="line">    <span class="keyword">if</span>(L-&gt;data==x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        p=L;  </span><br><span class="line">        L=L-&gt;next; <span class="comment">// (1)单链表保持连续 </span></span><br><span class="line">        <span class="built_in">free</span>(p);  </span><br><span class="line">        deleteX(L,x); <span class="comment">// (2)递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        deleteX(L-&gt;next,x); <span class="comment">//(3)向后遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>理解难度在于似乎仅仅只是释放了当前结点并使得L向前推进，而导致了断链。</p>
<blockquote>
<p>例如要在单链表$[1, 3, 5, 7]$中删除元素$x$(例如$x=3$)，这里递归第二次调用函数讲会遇到$data==3$</p>
</blockquote>
<p>核心理解在于这里的LinkList L是<strong>引用</strong>, 观察堆栈会非常清晰的说明这个问题。</p>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/134486032@N03/36580955782/in/dateposted-public/" title="deleteX" target="_blank" rel="noopener"><img src="https://farm5.staticflickr.com/4381/36580955782_32532b105a.jpg" width="500" height="500" alt="deleteX"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<p>当代码中$(2)$处递归调用deleteX时, 参数作为L-&gt;next的引用传入(引用为别名，相当于本体操作)，即<strong>递归中参数L为上一函数的L-&gt;next本体</strong>，此时的代码相当于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deleteX(L-&gt;next, x)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    p = L-&gt;next;  </span><br><span class="line">    L-&gt;next = L-&gt;next-&gt;next; <span class="comment">// 单链表保持连续 </span></span><br><span class="line">    <span class="built_in">free</span>(p);  </span><br><span class="line">    deleteX(L-&gt;next, x);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>如若将引用更换为指针，相较于引用的实现较为繁琐，但更能观察到上述代码工作的本质。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅有传入指针的指针才能改变上一函数中指针的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteX</span><span class="params">(LinkList **L, ElemType x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    LNode *p;  </span><br><span class="line">    <span class="keyword">if</span>((*L)==<span class="literal">NULL</span>) <span class="keyword">return</span>;  </span><br><span class="line">    <span class="keyword">if</span>((*L)-&gt;data==x)  <span class="comment">// L-&gt;next指向的结点为x</span></span><br><span class="line">    &#123;  </span><br><span class="line">        p=*L;  <span class="comment">// p指向L-&gt;next指向的结点</span></span><br><span class="line">        *L=(*L)-&gt;next; <span class="comment">// L-&gt;next=L-&gt;next-&gt;next</span></span><br><span class="line">        <span class="built_in">free</span>(p);  </span><br><span class="line">        deleteX(L,x); <span class="comment">// 传入L-&gt;next的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        deleteX(&amp;((*L)-&gt;next),x); <span class="comment">// 传入L-&gt;next指向的结点的next指针的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                      </p>
                    </div>
                  </div>
                  <br>
                  <br>
                  
                  <div class="card is-white is-hover" id="articleCard">
                    <div class="card-header">
                      <a href="/2018/03/07/2017-07-09-Atmos坐标变换/" class="card-header-title">
                        Atmos坐标变换
                      </a>
                    </div>
                    <div class="card-content">
                      <p id="articleContent">
                        <h3 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h3><blockquote>
<p>通常摄像机动画，模型动画中会使用旋转平移变换来完成坐标变换。这里使用基变换来完成通用的坐标系转换。</p>
</blockquote>
<p>现要求得世界坐标$P_{world}$对应的代求坐标系$\Omega$下坐标$P_{\Omega}$，已知$\Omega$坐标轴向量分别为$\overset{\rightharpoonup}{X}, \overset{\rightharpoonup}{Y}, \overset{\rightharpoonup}{Z}$,坐标原点为$O$</p>
<p>$$worldToObject<br>\left(<br>\begin{matrix}<br>\overset{\rightharpoonup}{X}.x &amp; \overset{\rightharpoonup}{Y}.x &amp; \overset{\rightharpoonup}{Z}.x &amp; O.x \\\ <br>\overset{\rightharpoonup}{X}.x &amp; \overset{\rightharpoonup}{Y}.y &amp; \overset{\rightharpoonup}{Z}.y &amp; O.y \\\\<br>\overset{\rightharpoonup}{X}.z &amp; \overset{\rightharpoonup}{Y}.z &amp; \overset{\rightharpoonup}{Z}.z &amp; O.z \\\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right)$$</p>
<p>即有$P_{\Omega}=worldToObject * P_{world}$.(该矩阵含义可展开其含义自明)</p>
<h3 id="PBRT以及Atmos中关于相机各类坐标系的转换"><a href="#PBRT以及Atmos中关于相机各类坐标系的转换" class="headerlink" title="PBRT以及Atmos中关于相机各类坐标系的转换"></a>PBRT以及Atmos中关于相机各类坐标系的转换</h3><blockquote>
<p>PBRT中的NDC坐标系在Atmos中未使用，因为其本身在PBRT中并不直接体现</p>
</blockquote>
<p>具体的转换管线流程如下，实现公式可由下图各自推导出来，不做赘述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rasterPosition(imageX, imageY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// raster to screen</span></span><br><span class="line">screenPosition(rasterPosition.x - image-&gt;width / <span class="number">2.0f</span>, -rasterPosition.y + image-&gt;height / <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// screen to camera</span></span><br><span class="line"><span class="comment">// 这里pbrt中使用投影矩阵的逆变换得到cameraPos，不过由于透视的特殊性，其方向向量是一致的。</span></span><br><span class="line">cameraPosition.x = <span class="number">2</span> * canvasSize.x * screenPosition.x / image-&gt;width;</span><br><span class="line">cameraPosition.y = <span class="number">2</span> * canvasSize.y * screenPosition.y / image-&gt;height;</span><br><span class="line">cameraPosition.z = canvasDistance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// camera to world</span></span><br><span class="line">ray-&gt;direction = (cameraToWorld * cameraPosition).getNormalized();</span><br><span class="line">ray-&gt;origin = cameraToWorld * zeroVector3;</span><br></pre></td></tr></table></figure>
<p><img src="https://farm5.staticflickr.com/4264/35005454923_f05e8118e1_b.jpg" alt=""></p>
<p>之后可以用worldToCamera矩阵进行转换。</p>
<p>$$worldToCamera<br>\left(<br>\begin{matrix}<br>right.x &amp; up.x &amp; direction.x &amp; origin.x \\\ <br>right.x &amp; up.y &amp; direction.y &amp; origin.y \\\\<br>right.z &amp; up.z &amp; direction.z &amp; origin.z \\\\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right)$$</p>

                      </p>
                    </div>
                  </div>
                  <br>
                  <br>
                  
                  <div class="card is-white is-hover" id="articleCard">
                    <div class="card-header">
                      <a href="/2018/03/07/2017-03-13-Monte Carlo Integration/" class="card-header-title">
                        Monte Carlo Integration
                      </a>
                    </div>
                    <div class="card-content">
                      <p id="articleContent">
                        <blockquote>
<p>蒙特卡洛方法求积分以及部分所需的概率论术语可以在<a href="http://www.pbrt.org/" target="_blank" rel="noopener">PBRT</a>以及概率论与数理统计中找到</p>
</blockquote>
<p>PBRT中给出了蒙特卡洛估计量，其中随机变量$X_i \in [a,b]$且独立同分布，分布满足概率密度函数 $p(x)$。</p>
<p>$$F_N = \frac{1}{N}\sum^{N}_{i=1}\frac{f(X_i)}{p(X_i)}$$</p>
<p>其期望为</p>
<p>$$\begin{split}<br>E[F_N] &amp; = E[\frac{1}{N}\sum_{i=1}^{N}\frac{f(X_i)}{p(X_i)}] \\\\<br>&amp; = \frac{1}{N}\sum_{i=1}^{N}\int_{a}^{b}\frac{f(x)}{p(x)}p(x)dx \\\\<br>&amp; = \frac{1}{N}\sum_{i=1}^{N}\int_{a}^{b}f(x)dx \\\\<br>&amp; = \int_{a}^{b}f(x)dx \\\\<br>\end{split}<br>$$</p>
<p>方差为 </p>
<p>$$\sigma^2=\frac{1}{N}\int(\frac{f(x)}{p(x)}-I)^2p(x)dx$$</p>
<p>结果的误差与标准差成正比，因此随着样本数增加误差缩小速度仅与$\sqrt{N}$相关(即常说的增加4倍采样数目才能缩小一半的误差)</p>
<blockquote>
<p>PBRT以及许多其他文章书籍等直接给出了这个估计量的期望计算（其中第二步到第三步并未直接说明来由，尽管PBRT在对期望的简介中已给出式子），这一步<strong>只能证明估计量本身无偏*</strong>。</p>
</blockquote>
<blockquote>
<p>以下将给出证明</p>
</blockquote>
<blockquote>
<p>引用一个知识点: <a href="https://en.wikipedia.org/wiki/Law_of_the_unconscious_statistician" target="_blank" rel="noopener">Law of the unconscious statistician</a>，简称LOTUS。用法是已知随机变量X的分布$f_X$，但并不知道函数g(X)的分布$f_{g(X)}$。那么此时函数$g(X)$的期望为</p>
</blockquote>
<blockquote>
<p>$E[g(X)]=\sum_x g(x)f_X(x)$(X为离散型随机变量)</p>
</blockquote>
<blockquote>
<p>$E[g(X)]=\int_{-\infty}^{\infty} g(x)f_X(x)dx$(X为连续型随机变量)</p>
</blockquote>
<blockquote>
<p>此处细节介绍也可以看<a href="http://www.qiujiawei.com/monte-carlo/" target="_blank" rel="noopener">Wyman的技术博客</a>，其中就提到了许多地方都没有涉及到的LOTUS。</p>
</blockquote>
<p>$$\begin{split}<br>E[ \frac {f(X_{i})}{pdf(X_{i})} ] &amp; = E[ \frac {f(x)}{pdf(x)} ] \\\\<br>&amp; = \int _{a}^{b}\frac {f(x)}{pdf(x)}pdf(x)dx \\\\<br>&amp; = \int _{a}^{b}f(x)dx<br>\end{split}<br>$$</p>
<blockquote>
<p>这里积分区间变为$[-\infty, \infty]$也是如此。以下将会使用到<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">大数定律</a>的知识背景。</p>
</blockquote>
<blockquote>
<p>引用自维基百科：设 $a_{1},a_{2},…,a_{n},…$为相互独立的随机变量，其数学期望为： $E(a_{i})=\mu (i=1,2,…)$，方差为： $Var(a_{i})=\sigma ^{2}(i=1,2,…)$<br>则序列$\overline{a} = \frac{1}{n} \sum_{i=1}^{n}$，$a_{i}$ 依概率收敛于 $\mu$（即收敛于此数列的数学期望 $E(a_{i})$）。</p>
</blockquote>
<p>取一组独立同分布的随机变量$\{\xi\}$，且$\xi$在$[a,b]$内满足分布律$p(x)$，则令$p^<em>(x)=\frac{f(x)}{p(x)}$，**则$\{ p^</em>(\xi_i) \}$也是一组独立同分布的随机变量。**，那么计算其得到的期望其实就是积分本身(见下)。</p>
<p>由大数定理</p>
<p>$$Pr(\lim_{N\to\infty}\frac{1}{N}\sum_{i=1}^{N}p^*(\xi_i)=I)=1$$</p>
<p>那么这里已经有随机变量$\{ p^<em>(\xi_i) \}$存在，且期望等于积分值，**那么根据大数定理可知，这里的$\{ p^</em>(\xi_i) \}$就是会依概率收敛于积分值。**证毕。</p>

                      </p>
                    </div>
                  </div>
                  <br>
                  <br>
                  
                  <div class="card is-white is-hover" id="articleCard">
                    <div class="card-header">
                      <a href="/2018/03/07/2017-03-09-Inverse Transform Sampling/" class="card-header-title">
                        Inverse Transform Sampling
                      </a>
                    </div>
                    <div class="card-content">
                      <p id="articleContent">
                        <blockquote>
<p>具体理论学习推导参考<a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling" target="_blank" rel="noopener">Wikipedia</a>,<a href="http://www.columbia.edu/~ks20/4404-Sigman/4404-Notes-ITM.pdf" target="_blank" rel="noopener">Inverse Transform Method</a>，<a href="http://www.pbrt.org/" target="_blank" rel="noopener">PBRT-P643</a>, </p>
</blockquote>
<blockquote>
<p>下文中的CDF与PDF等概率论术语定义可在概率论与数理统计等书中找到</p>
</blockquote>
<p>生成一个随机数满足一个已知解析式的分布，是一个非常常见的需求(C++11已经内部提供不少给定分布)，这里将推导如何将最常见的均匀分布随机数转换为其他已知解析式的分布。</p>
<p>先把结论放在这里，<strong>若有一随机变量X满足分布PDF（对应一CDF），使用一个均匀分布的随机变量Y，则Y对该CDF的反函数进行采样的结果满足PDF。</strong></p>
<blockquote>
<p>以下内容摘自Wikipedia</p>
</blockquote>
<p>已知有分布$F(x)=1-e^{-\lambda x}$，其中$x\geqslant 0$，可以求得CDF的反函数，如下图所示。</p>
<p>$$x=F^{-1}(y)=-\frac{1}{\lambda}(1-y)$$</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Inverse_transformation_method_for_exponential_distribution.jpg/400px-Inverse_transformation_method_for_exponential_distribution.jpg" alt=""></p>
<p>其中$y_i$是满足区间(0, 1)均匀分布的随机数(即，Y~U(0, 1))，这里可以明显看到由反函数求得的X的分布情况，在越接近0的位置分布的越多，越背离则越稀疏，满足对于结果的设想。</p>
<blockquote>
<p>证明</p>
</blockquote>
<p>若有CDF满足$F(x)=Pr\{X\leqslant x\}$，则起反函数$F^{-1}$满足</p>
<p>$$F^{-1}(y)=min\{x: F(x)\geqslant y\}, y\in [0, 1]$$</p>
<p>之所以使用下确界的原因是，$F(x)$满足右连续且单调不减</p>
<p>令$X=F^{-1}(U)$其中$U$满足在区间$[0,1]$上连续均匀分布，现要证</p>
<p>$$Pr\{X\leqslant x\}=F(x), x\in \Re$$</p>
<p>则要证$Pr\{F^{-1}(U)\leqslant x\}=F(x)$成立。此处$F$连续且单调不减，则同时对不等式套用$F$不等式成立</p>
<p>$$\{F^{-1}(U)\leqslant x\}=\{U\leqslant F(x)\}$$</p>
<p>则有$Pr\{U\leqslant F(x)\}$成立，下图中描述了$U\leqslant F(x)$的概率就等于$F(x)$本身</p>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/134486032@N03/32527569383/in/dateposted-public/" title="无标题" target="_blank" rel="noopener"><img src="https://c1.staticflickr.com/1/692/32527569383_039ba28810.jpg" width="431" height="296" alt="无标题"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<p>则得证<br>$$Pr\{F^{-1}(U)\leqslant x\}=F(x)$$</p>
<hr>
<p>有了Inverse CDF这项工具，就可以很方便的将已有的满足均匀分布的随机数转化为满足一已知PDF的随机数分布。</p>
<blockquote>
<p>二维随机变量中条件概率直观理解(其中关于联合以及边缘分布律/概率密度分布的概念可以在<a href="http://math.sjtu.edu.cn/course/gltj/xxzl/he/ch31.pdf" target="_blank" rel="noopener">上海交大的PPT</a>以及<a href="https://zh.wikipedia.org/wiki/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83" target="_blank" rel="noopener">Wikipedia</a>中找到)。在渲染中主要在重要性采样中会用到二维随机变量的这些概念</p>
</blockquote>
<p><strong>离散条件分布</strong>和<strong>连续条件分布</strong>的定义都可以在引用中看到，这里只关注离散型二维随机变量的分布。</p>
<p>首先有联合=条件*边缘的定义，当然同时要满足$\sum_{x}\sum_{y}P(X=x, Y=y)=1$的前提条件。</p>
<p>$$P(X=x, Y=y)=P(Y=y|X=x)P(X=x)=P(X=x|Y=y)P(Y=y)$$</p>
<p>若X,Y满足相互独立，那么也满足以下等式</p>
<p>$$P(X=x, Y=y)=P(Y=y)P(X=x)$$</p>
<p>在渲染中为了对图像上亮度更高的点有更高的概率采样到，那么势必要生成满足图像PDF的二维随机变量。此处易证在图像的采样上，<strong>X与Y二者之间非相互独立</strong>。</p>
<blockquote>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/134486032@N03/32511394224/in/dateposted-public/" title="XY独立性证明" target="_blank" rel="noopener"><img src="https://c1.staticflickr.com/4/3886/32511394224_a983cf5254.jpg" width="500" height="262" alt="XY独立性证明"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
</blockquote>
<blockquote>
<p>此图中$P(X=x, Y=y)=\frac{b}{b+8a}$，而$P(X=x)=P(Y=y)=\frac{b}{b+4a}$，容易看出$P(X=x, Y=y)\not = P(Y=y)P(X=x)$</p>
</blockquote>
<p>那么求解上述就只剩下一种途径，就是对于给定图像求解边缘以及条件分布函数。这也是PBRT中使用边缘+条件来生成联合的原因。</p>
<blockquote>
<p>以下使用OF测试得到的可视化结果，因为一维采样重建可以在二维中体现因此此处不做一维对比。具体实现办法可以在PBRT的Distribution中看到详细过程</p>
</blockquote>
<p>左右为不同采样数量但可以明显发现在图像中亮度较高位置采样数量更多，采样结果明显偏向于向图像亮处。</p>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/134486032@N03/32990051490/in/dateposted-public/" title="采样对比2" target="_blank" rel="noopener"><img src="https://c1.staticflickr.com/3/2818/32990051490_018f71494b_b.jpg" width="1024" height="768" alt="采样对比2"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<blockquote>
<p>这里图像较暗是因为<strong>没有</strong>采用Tone Mapping的关系，但因为不影响全局显示，因此没做特殊处理。此处若使用普通PNG等被截断过的图像则无法有效的对图像上高光部分进行有效采样。</p>
</blockquote>

                      </p>
                    </div>
                  </div>
                  <br>
                  <br>
                  
                  <div class="card is-white is-hover" id="articleCard">
                    <div class="card-header">
                      <a href="/2018/03/05/2017-03-27-Transformation In Multiple Dimensions/" class="card-header-title">
                        Transformation In Multiple Dimensions
                      </a>
                    </div>
                    <div class="card-content">
                      <p id="articleContent">
                        <blockquote>
<p>本文运用上文中多维随机变量分布转换规律，来推导出PBRT中一系列重要结论</p>
</blockquote>
<hr>
<blockquote>
<p><strong>极坐标与笛卡尔坐标</strong></p>
</blockquote>
<p>已知$p(x, y)=\frac{p(r, \theta)}{\arrowvert J_t(r, \theta) \arrowvert}$，其中<br>$$T_1(r,\theta)=rcos\theta=x \\<br>T_2(r,\theta)=rsin\theta=y$$</p>
<p>$$J_t(r, \theta)=\left[<br>\begin{matrix}<br>cos\theta &amp; -rsin\theta \\<br>sin\theta &amp; rcos\theta \\<br>\end{matrix}<br>\right] = r$$</p>
<p>则有$p(r, \theta) = rp(x, y)$</p>
<hr>
<blockquote>
<p><strong>球坐标与笛卡尔坐标</strong></p>
</blockquote>
<p>$$T_1(r,\theta, \phi)=rsin\theta cos\phi = x \\<br>T_2(r,\theta, \phi)=rsin\theta sin\phi = y \\<br>T_3(r,\theta, \phi)=rcos\theta = z$$</p>
<p>则$p(x, y, z)=\frac{p(r, \theta, \phi)}{\arrowvert J_t(r, \theta, \phi) \arrowvert}$，其中</p>
<p>$$J_t(r, \theta, \phi)=\left[<br>\begin{matrix}<br>sin\theta cos\phi &amp; rcos\theta cos\phi &amp; -rsin\theta sin\phi \\<br>sin\theta sin\phi &amp; rcos\theta sin\phi &amp; rsin\theta cos\phi \\<br>cos\theta &amp; -rsin\theta &amp; 0 \\<br>\end{matrix}<br>\right] = r^2sin\theta$$</p>
<p>则有$p(r, \theta, \phi) = r^2sin\theta p(x, y, z)$。</p>
<hr>
<blockquote>
<p><strong>立体角与球坐标</strong></p>
</blockquote>
<p>立体角的定义为在单位圆上投影的面积，在球坐标中有$d\omega=sin\theta d\theta d\phi$成立</p>
<blockquote>
<p>因此基于物理Lambertion中的$\int_{\Omega}{f(\omega_i, \omega_o, p)cos\theta d\omega}$=1, 可得$f(\omega_i, \omega_o, p) = \frac{1}{\int_{0}^{2\pi}d\phi \int_{0}^{\frac{\pi}{2}}{cos\theta sin\theta d\theta}} = \frac{1}{\pi}$</p>
</blockquote>
<p>若定义在某区域$\Omega$上的概率为$Pr\{ \omega \in \Omega \} = \int_{\Omega}{p(\omega)d\omega}$，也有$Pr\{ (\theta ,\phi) \in \Omega ‘\} = \int_{\Omega ‘}{p(\theta, \phi)d\theta d\phi}$</p>
<p>因此<br>$$p(\theta, \phi)d\theta d\phi=p(\omega) d\omega$$<br>$$p(\theta, \phi)=sin\theta p(\omega)$$</p>
<hr>
<blockquote>
<p><strong>半球上立体角均匀采样</strong></p>
</blockquote>
<p>要对单位半球做关于立体角的均匀采样，则$p(\omega)=\frac{1}{2\pi}$，根据上文中与球坐标关系，$p(\theta, \phi)=\frac{sin\theta}{2\pi}$。</p>
<p>则有两独立同均匀分布随机变量$(\xi,\psi)\in [0,1]$，要转换成满足半球上均匀分布的球坐标表示。</p>
<p>$$p(\theta) = \int_{0}^{\frac{\pi}{2}}p(\theta, \phi)d\phi = sin\theta, \quad p(\phi) = \int_{0}^{2\pi}p(\theta, \phi)d\theta = \frac{1}{2\pi} $$</p>
<p>$$p(\theta \arrowvert \phi) = \frac{p(\theta, \phi)}{p(\phi)}=sin\theta, \quad p(\phi \arrowvert  \theta) = \frac{p(\theta, \phi)}{p(\theta)}=\frac{1}{2\pi}$$</p>
<blockquote>
<p>这里很明显可以看出来$\theta,\phi$为两个独立随机变量</p>
</blockquote>
<p>$$Pr\{\theta’ \leqslant  \theta\} = \int_{0}^{\theta}p(\theta)d\theta=1-cos\theta , Pr\{\phi’ \leqslant  \phi\} = \int_{0}^{\phi}p(\phi)d\phi=2\pi \phi$$</p>
<p>应用反CDF变换法则，$P^{-1}(\theta)=1-arccos\theta, P^{-1}(\phi)=2\pi \phi$，因此<br>$$\theta=arccos(1-\xi)=arccos\xi \\<br>\phi=2\pi \psi$$</p>
<p>由于球坐标不容易在计算机中表示，因此转换为笛卡尔表示</p>
<p>$$x=sin\theta cos\phi=\sqrt{1-\xi^2}cos2\pi \psi \\<br>y = sin\theta sin\phi = \sqrt{1-\xi^2}sin2\pi \psi \\<br>z = cos\theta = \xi$$ </p>
<blockquote>
<p>同理可推证球上立体角均匀采样</p>
</blockquote>
<blockquote>
<p>$$x=2\sqrt{\xi(1-\xi)}cos2\pi \psi \\<br>y = 2\sqrt{\xi(1-\xi)}sin2\pi \psi \\<br>z = 1-2\xi$$ </p>
</blockquote>
<p>下图为半球上均匀采样的结果与完整球上均匀采样的结果</p>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/134486032@N03/32882394873/in/dateposted-public/" title="hemisphere and sphere" target="_blank" rel="noopener"><img src="https://c1.staticflickr.com/4/3827/32882394873_657e2d78a4_z.jpg" width="640" height="248" alt="hemisphere and sphere"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<hr>
<blockquote>
<p><strong>单位圆上的均匀采样</strong></p>
</blockquote>
<p>要根据面积对单位圆上进行均匀采样，$p(x,y)=\frac{1}{\pi}$，则$p(r, \theta)=rp(x,y)$。</p>
<p>$$p(\theta)=\int_{0}^{1}\frac{r}{\pi}dr=\frac{1}{2\pi}, \quad p(r\arrowvert \theta)=\frac{p(r,\theta)}{p(\theta)}=2r$$</p>
<p>则他们对于的CDF为$P(\theta)=\int_{0}^{\theta}p(\theta)d\theta=\frac{\theta}{2\pi}$，$P(r\arrowvert \theta)=\int_{0}^{r}p(r\arrowvert \theta)dr=r^2$</p>
<p>求出其对应反函数$P^{-1}(\theta)=2\pi\theta$，$P^{-1}(r\arrowvert \theta)=\sqrt{r}$</p>
<p>若有两满足在$[0, 1]$上均匀分布的随机变量$\xi, \psi$有$\theta=2\pi \xi, r=\sqrt{\psi}$</p>
<p>则转换回笛卡尔坐标结果为</p>
<p>$$x = \sqrt{\psi}cos2\pi \xi \\<br>y = \sqrt{\psi}sin2\pi \xi$$</p>
<blockquote>
<p>这里$r, \theta$也是两个独立的随机变量</p>
</blockquote>
<blockquote>
<p>PBRT中论述的Concentric Disk Sampling可以参见前文<a href="http://bentleyblanks.github.io/Depth-of-Field/" target="_blank" rel="noopener">Depth of Field</a>中的实现与可视化</p>
</blockquote>
<hr>
<blockquote>
<p><strong>基于Cosine函数的半球采样</strong></p>
</blockquote>
<p>这里使用基本的转换思路，$p(\omega)\propto cos\theta$，因此$p(\omega)=\frac{cos\theta}{\pi}$</p>
<p>有$p(\theta, \phi)=\frac{sin\theta cos\theta}{\pi}$，则有</p>
<p>$$p(\theta)=\int_{0}^{2\pi}p(\theta, \phi)d\phi=2sin\theta cos\theta, \quad p(\phi \arrowvert \theta)=\frac{p(\theta, \phi)}{p(\theta)}=\frac{1}{2\pi}$$</p>
<p>可得CDF为</p>
<p>$$P(\theta)=\int_{0}^{\theta}p(\theta)d\theta=\frac{1-cos2\theta}{2}, \quad P(\phi \arrowvert \theta)=\int_{0}^{\phi}p(\phi \arrowvert \theta)d\phi=\frac{\phi}{2\pi}$$</p>
<p>应用反CDF得$P^{-1}(\theta)=\frac{1}{2}arccos(1-2\theta), P^{-1}(\phi \arrowvert \theta)=2\pi \phi$</p>
<p>$$\theta = \frac{1}{2}arccos(1-2\xi) \\<br>\phi = 2\pi \psi$$</p>
<p>转换为笛卡尔下的表示为<br>$$x=sin\theta cos\phi = sin(\frac{1}{2}arccos(1-2\xi)))cos2\pi\psi \\<br>y=sin\theta sin\phi =  sin(\frac{1}{2}arccos(1-2\xi)))sin2\pi\psi \\<br>z=cos\theta = cos(\frac{1}{2}arccos(1-2\xi))$$</p>
<blockquote>
<p>PBRT中给出了另一种计算办法，将均匀分布在圆盘上的点投影到半球上，其结果就满足Cosine-Weighted。</p>
</blockquote>
<p>以下给出证明</p>
<p>假定在圆盘上的极坐标分布为$p(r, \phi)=\frac{r}{\pi}$（使用$\phi$方便后续将$r$对应为$\theta$相关），$p(r, \phi)=\frac{p(\theta, \phi)}{\arrowvert J_t(r, \theta)\arrowvert}$</p>
<p>$$r=sin\theta = T_1(r) \\<br>\phi=\phi = T_2(\phi)$$</p>
<p>$$J_t(r, \theta)=\left[<br>\begin{matrix}<br>cos\theta &amp; 0 \\<br>0 &amp; 1 \\<br>\end{matrix}<br>\right] = cos\theta$$</p>
<p>即有$p(\theta, \phi)=cos\theta p(r, \phi)=\frac{r cos\theta}{\pi} = \frac{sin\theta cos\theta}{\pi}$，和上述中得到的结果一样。</p>
<blockquote>
<p>下图为两种方法产生的Cosine-Weighted对比</p>
</blockquote>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/134486032@N03/33311690620/in/dateposted-public/" title="cartisan and projected" target="_blank" rel="noopener"><img src="https://c1.staticflickr.com/4/3838/33311690620_dabe17df74_z.jpg" width="640" height="248" alt="cartisan and projected"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<hr>
<blockquote>
<p><strong>三角形均匀采样</strong></p>
</blockquote>
<p>PBRT中采用了等腰切两边为1的三角形特殊情况，不过以下计算办法可以变换回任何三角形</p>
<p>有$p(u,v)=2$（面积倒数），则有</p>
<p>$$p(u)=\int_{0}^{1-u}p(u,v)dv=2-2u, \quad p(v\arrowvert u)=\frac{p(u,v)}{p(u)}=\frac{1}{1-u} \\<br>P(u)=\int_{0}^{u}p(u)du=2u-u^2, \quad P(v\arrowvert u)=\int_{0}^{v}p(v\arrowvert u)dv=\frac{v}{1-u}$$</p>
<blockquote>
<p>这里反变换CDF开根号时要注意到$u,v\in [0,1]$</p>
</blockquote>
<p>因此有$u=1-\sqrt{\xi},v=\sqrt{\xi}\psi$</p>
<blockquote>
<p>下图中即为三角形上的均匀采样</p>
</blockquote>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/134486032@N03/33311534320/in/dateposted-public/" title="triangle sample" target="_blank" rel="noopener"><img src="https://c1.staticflickr.com/3/2841/33311534320_9991e8b365_z.jpg" width="640" height="339" alt="triangle sample"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<hr>
<blockquote>
<p><strong>根据二维分段函数分布采样</strong></p>
</blockquote>
<p>这里分段函数的采样即为离散随机变量，若有横向纵向各$n_u,n_v$个元素，函数上指定位置一点值为$f(u,v)$，那么就有</p>
<p>$$I_f=\int_v \int_u f(u,v)dudv=\frac{1}{n_un_v}\sum_{i=0}^{n_u-1}\sum_{j=0}^{n_v-1}f(u_i,v_j) \\<br>p(u,v)=\frac{f(u,v)}{I_f}$$</p>
<p>而边缘概率密度可直接得到<br>$$p(u)=\int_v p(u,v)dv=\frac{\frac{1}{n_u}\sum_i f(u, v_i)}{I_f} , \quad p(v\arrowvert u)=\frac{p(u,v)}{p(u)}=\frac{f(u,v)}{\frac{1}{n_u}\sum_i f(u, v_i)}$$</p>
<p>之后利用CDF反变换，即PBRT中distribution1d的实现办法可完成对于$p(u),p(v\arrowvert u)$上的采样</p>
<blockquote>
<p>此处效果可见<a href="http://bentleyblanks.github.io/Transforming-Between-Distributions/" target="_blank" rel="noopener">前文</a>中的二维分段函数采样的结果</p>
</blockquote>
<hr>
<blockquote>
<p><strong>圆锥均匀采样</strong></p>
</blockquote>
<blockquote>
<p>类似于球上的均匀采样, 易证随机变量$\theta, \phi$相互独立</p>
</blockquote>
<p>已知$p(\omega)=\frac{1}{2\pi(1-cos\theta_{max})}$，则$p(\theta, \phi)=\frac{sin\theta}{2\pi(1-cos\theta_{max})}$</p>
<p>$$p(\theta)=\int_{0}^{2\pi}p(\theta, \phi)d\phi=\frac{sin\theta}{1-cos\theta_{max}}, \quad p(\phi)=\int_{0}^{2\pi}\frac{sin\theta}{2\pi(1-cos\theta_{max})}d\theta=\frac{1}{2\pi}$$</p>
<p>$$P(\theta)=\int_{0}^{\theta}\frac{sin\theta}{1-cos\theta_{max}}d\theta=\frac{1-cos\theta}{1-cos\theta_{max}}, \quad P(\phi)=\int_{0}^{\phi}\frac{1}{2\pi}d\phi=\frac{\phi}{2\pi}$$</p>
<p>若有两随机变量$xi, \psi$，运用反变换可有（此处省略了$\theta, \phi$到笛卡尔的转换）</p>
<p>$$cos\theta=1-\xi +\xi cos\theta_{max}, \quad \phi=2\pi\psi$$</p>
<blockquote>
<p>下图中即为圆锥上的均匀采样</p>
</blockquote>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/134486032@N03/33700555886/in/dateposted-public/" title="cone sampling" target="_blank" rel="noopener"><img src="https://c1.staticflickr.com/3/2822/33700555886_1fe03e48cd_z.jpg" width="640" height="369" alt="cone sampling"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>

                      </p>
                    </div>
                  </div>
                  <br>
                  <br>
                  
                  <div class="card is-white is-hover" id="articleCard">
                    <div class="card-header">
                      <a href="/2018/03/05/2017-03-26-Transforming Between Distributions/" class="card-header-title">
                        Transforming Between Distributions
                      </a>
                    </div>
                    <div class="card-content">
                      <p id="articleContent">
                        <blockquote>
<p>关于连续型随机变量的分布转换，除了使用反CDF函数将均匀分布函数转换为其他分布函数以外，存在一种通用办法实现不同分布之间的转换，不只局限于均匀分布。</p>
</blockquote>
<p>假定存在随机变量$X$，其累积分布函数为$F_X(x)$。若存在单调函数$g$，使得$Y=g(X)$（因为是单调函数，因此$X$与$Y$的关系为单射），则为了计算$Y$的累积分布函数$F_Y(y)$，</p>
<blockquote>
<p>设$g(x)$此时为严格单调递增</p>
</blockquote>
<p>$$\begin{split}<br>F_Y(y) &amp; = &amp; Pr\{ Y\leqslant y \} \\<br>&amp; = &amp; Pr\{g(X)\leqslant y\} \\<br>&amp; = &amp; Pr\{ X\leqslant g^{-1}(y) \} \\<br>&amp; = &amp; F_X(g^{-1}(y))<br>\end{split}$$</p>
<p>此时对终式左右对x求导(累积分布函数导数为概率密度函数)</p>
<p>$$\begin{split}<br>f_Y(y)\frac{dy}{dx}=f_X(g^{-1}(y)) \\<br>f_Y(y) = (\frac{dy}{dx})^{-1}f_X(g^{-1}(y))  \\<br>\end{split}$$</p>
<blockquote>
<p>再设$g(x)$此时为严格单调递减</p>
</blockquote>
<p>$$\begin{split}<br>F_Y(y) &amp; = &amp; Pr\{ Y\leqslant y \} \\<br>&amp; = &amp; Pr\{g(X)\leqslant y\} \\<br>&amp; = &amp; 1 - Pr\{ X\leqslant g^{-1}(y) \} \\<br>&amp; = &amp; 1 - F_X(g^{-1}(y))<br>\end{split}$$</p>
<p>同样的有<br>$$f_Y(y) = -(\frac{dy}{dx})^{-1}f_X(g^{-1}(y))$$</p>
<p>则有$f_Y(y) = \arrowvert (\frac{dy}{dx})^{-1}\arrowvert f_X(g^{-1}(y))$。</p>
<blockquote>
<p>PBRT中讲到，当我们有一概率密度为$p_x(x)$的随机变量$X$，想要转换为满足已知分布为$p_y(y)$的随机变量$Y$，那么即有下式成立(此过程与上式正好相反)</p>
</blockquote>
<p>$$\begin{split}<br>F_X(x) &amp; = &amp; Pr\{ X\leqslant x \} \\<br>&amp; = &amp; Pr\{g(X)\leqslant g(x)\} \\<br>&amp; = &amp; Pr\{ Y\leqslant g(x) \} \\<br>&amp; = &amp; F_Y(g(x))<br>\end{split}$$</p>
<blockquote>
<p>$g(x) = F_Y^{-1}(F_X(x))$或当$g(X)$为单调减函数时$g(x) = F_Y^{-1}(1 - F_X(x))$，PBRT中未对此处进行详细说明。</p>
</blockquote>
<p>因此当$X$为满足$[0, 1]$区间均匀分布的随机变量时，$F_X(x)=x$，那么上式中$F_X(x))$或是$1 - F_X(x)$都满足$[0, 1]$区间均匀分布，则$g(x)=F_Y^{-1}(x)$，即Inverse Transform Sampling得证。</p>
<p>多维随机变量的转换$T(x)$为双射变换，则满足$f_Y(y)=f_Y(T(x))=\frac{f_X(x)}{\arrowvert J_T(x)\arrowvert }$，且$T(x)=(T_1(x),\cdots T_n(x))$</p>
<p>$$J_T(x)=\left[<br>\begin{matrix}<br> \frac{\partial T_1}{\partial x_1}    &amp; \cdots &amp; \frac{\partial T_1}{\partial x_n}      \\<br> \vdots &amp; \ddots &amp; \vdots \\<br> \frac{\partial T_n}{\partial x_1}    &amp; \cdots &amp; \frac{\partial T_n}{\partial x_n}      \\<br>\end{matrix}<br>\right]$$</p>

                      </p>
                    </div>
                  </div>
                  <br>
                  <br>
                  
              
          </div>
        </div>
      </div>
      <!-- about me -->
      <div class="column">
        <div class="card is-white is-hover is-hidden-mobile is-sticky">
          <div class="card-image">
            <figure class="image">
              <img src="http://pbrt.org/gallery/a3.jpg">
            </figure>
          </div>
          <div class="card-content">
            <div class="media">
              <div class="media-left">
                <figure class="image is-48x48">
                  <img src="https://github.com/BentleyBlanks.png">
                </figure>
              </div>
              <div class="media-content">
                <p class="title is-4">Bingo</p>
                <p class="subtitle is-6">@BentleyJobs</p>
              </div>
            </div>
            <div class="content">
              Graduated from <a href="https://www.jiangnan.edu.cn/">JNU</a>, interested in cg & game developing, once worked in <a href="https://www.aurogon.com/">Aurogon</a> to develope <a href="https://gjol.yy.com/">GuJianOL</a>. See <a href="">about</a> for more info.
            </div>
            <!-- icon link -->
            <div class="level is-mobile" id="iconLink">
              <!-- <div class="column"></div> -->

              <div class="level-item has-text-centered">
                <a class="fa fa-lg fa-map-marker" href="https://www.google.com/maps/place/Ningbo,+Zhejiang,+China/@29.8694844,121.2917787,10z/data=!3m1!4b1!4m5!3m4!1s0x344d6354630858f7:0x948723f846ccf173!8m2!3d29.868336!4d121.54399"></a>
              </div>
              <div class="level-item has-text-centered">
                <a class="fa fa-lg fa-github" href="https://github.com/BentleyBlanks/"></a>
              </div>
              <div class="level-item has-text-centered">
                <a class="fa fa-lg fa-envelope" href="mailto:bentleyjobs@gmail.com?subject=Hello%20again"></a>
              </div>
              <div class="level-item has-text-centered">
                <a class="fa fa-lg fa-weibo" href="https://weibo.com/2162074794"></a>
              </div>

              <!-- <div class="column"></div> -->
            </div>
          </div>
        </div>
      </div>
      <!-- <div class="column"></div> -->
    </div>
  </div>
</section>

<!-- <div class="container">
  <div class="colunms">
    <div class="colunm is-two-thirds">
		<div class="pagination-bar">
		    <ul class="pagination">
		        
		        
		        <li class="pagination-number">pagination.page pagination.of</li>
		    </ul>
		</div>
    </div>

    <div class="colunm"></div>
    <div class="colunm"></div>
  </div>
</div>
 -->

 <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">pagination.page pagination.of</li>
    </ul>
</div>



<!-- Footer -->
<footer class="footer is-medium" id="footerStyle">
  <div class="container">
    <nav class="level is-mobile">
      <!-- empty -->
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>

      <div class="level-item has-text-centered">
        <img src="https://yellowdi.github.io/Elenore/images/elenore-icon-outlined.png" alt="Elenore logo" width="50">
      </div>

      <div class="level-item has-text-centered">
        <img src="https://raw.githubusercontent.com/hexojs/logo/master/hexo-logo-avatar-transparent-background.png" alt="Hexo logo" width="50">
      </div>

      <!-- empty -->
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
      <div class="level-item has-text-centered"></div>
    </nav>

    <div class="columns has-text-centered">
      <div class="column">
        Theme Floekr developed By <a href="https://github.com/BentleyBlanks">Bingo</a>, based on <a href="https://yellowdi.github.io/Elenore">Elenore</a> and <a href="https://hexo.io/">Hexo</a>
      </div>
    </div>

    </div>
  </div>
  </div>
</footer>


  <!-- scripts list from theme config.yml -->
  
    <script src="/js/floekr.js"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


</body>
</html>
